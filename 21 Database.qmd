---
title: "21 Database"
format: html
editor: visual
---

```{r}
library(DBI)
library(dbplyr)
library(tidyverse)
```

## 21.3 Connecting to a database

-   To connect to the database from R, you'll use a pair of packages:

    -   You'll always use DBI (**d**ata**b**ase **i**nterface) because it provides a set of generic functions that connect to the database, upload data, run SQL, queries, etc.

    -   You'll also use a package tailored for the DBMS you're connecting to.

-   Concretely, you create a database connection using `DBI::dbConnect()`.

-   The first argument selects the DMBS, then the second and subsequent arguments describe how to connect to it. The following code shows a couple of typical examples:

    ```{r}
    con <- DBI::dbConnect(
      RMariaDB::MariaDB(),
      username = "foo"
    )

    con <- DBI::dbConnect(
      RPostgres::Postgres(),
      hostname = "databases.mycompany.com",
      port = 1234
    )
    ```

-   We'll use a in-process DBMS that lives entirely in a R package: `duckdb`.

-   Thanks to the magic of DBI, the only difference between using duckdb and any other DBMS is how you'll connect to the database.

    ```{r}
    con <- DBI::dbConnect(duckdb::duckdb())
    ```

### 21.3.2 Load some data

-   Since this is a new database, we need to start by adding some data.

-   Here we'll add `mpg` and `diamonds` datasets from ggplot2 using `DBI::dbWriteTable()`.

-   The simplest usage of `dbWriteTable()` needs three arguments: a database connection, the name of the table to create in the database, and a data frame of data

    ```{r}
    dbWriteTable(con, "mpg", ggplot2::mpg)
    dbWriteTable(con, "diamonds", ggplot2::diamonds)
    ```

### 21.3.3 DBI basics

-   You can check that the data is loaded correctly by using a couple of other DBI functions: `dbListTables()` lists all tables in the database and `dbReadTable()` retrieves the contents of a table.

    ```{r}
    dbListTables(con)
    ```

```{r}
con %>% 
  dbReadTable("diamonds") %>% 
  as_tibble()
```

-   `dbReadTable()` returns a `data.frame` so we use `as_tibble()` to convert it into a tibble so that it prints nicely.

-   If you already know SQL, you can use `dbGetQuery()` to get the results of running a query on the database:

    ```{r}
    sql <- "
    SELECT carat, cut, clarity, color, price
    FROM diamonds
    WHERE price > 15000"

    as_tibble(dbGetQuery(con, sql))
    ```

## 21.4 dbplyr basics

-   `dbplyr` is a dplyr **backend,** which means that you keep writing dplyr code but the backend executes it differently.

-   In this, dbplyr translates to SQL.

-   To use dbplyr, you must first use `tbl()` to create an object that represents a database table:

    ```{r}
    diamonds_db <- tbl(con, "diamonds")
    diamonds_db
    ```

-   This object is **lazy;** when you use dplyr verbs on it, dplyr doesn't do any work: it just records the sequence of operations that you want to perform and only performs then when needed.

-   For example, take the following pipeline:

    ```{r}
    big_diamonds_db <- diamonds_db %>% 
      filter(price < 15000) %>% 
      select(carat:clarity, price)

    big_diamonds_db
    ```

-   You can tell this object represents a database query because it prints the DBMS name at the top.

-   You can see the SQL code generated by the dplyr function `show_query()`. If you know dplyr, this is a great way to learn SQL!

    ```{r}
    big_diamonds_db %>% 
      show_query()
    ```

-   To get all the data back into R, you call `collect()`. Behind the scenes, this generates the SQL, calls `dbGetQuery()` to get the data, then turns the result into a tibble:

    ```{r}
    big_diamonds <- big_diamonds_db %>% 
      collect()

    big_diamonds
    ```

-   Typically, you'll use dbplyr to select the data you want from the database, performing basic filtering and aggregation operations. Then, once you're ready to analyse the data with functions that unique to R, you'll `collect()` the data to get an in-memory tibble.

------------------------------------------------------------------------

#### Lazy objects

-   In R, a **lazy object** refers to an object that is evaluated using **lazy evaluation.**

-   This means that the object is not computed or evaluated until it is actually needed.

-   For example, when a function is called in R, the arguments passed to the function are not evaluated immediately. Instead, they are stored as unevaluated expressions, and the evaluation happens only when the function references them.

-   Example:

    ```{r}
    lazy_fun <- function(x) {
      print("This will be evaluated only x is needed") 
      x + 1
    }


    # Calling the function without triggering evaluation of 'x'
    lazy_fun(expression(3 + 5)) # The expression is not evaluated until 'x + 1' is required.
    ```

#### dbplyr

-   `dbplyr` is an extension of `dbplyr` that allows you to work with databases using the same syntax you use for in-memory data frames.

-   The key difference is that instead of manipulating data directly in R, `dbplyr` translates your `dplyr` code into SQL and runs it on the database.

-   This gives you the power to work with large datasets efficiently without changing how you write your code.

    ------------------------------------------------------------------------

## 21.5 SQL

-   Luckily, if you understand `dplyr` you're in a great place to quickly pick up SQL because so many of the concepts are the same.

-   We'll explore the relationship between dplyr and SQL using a couple of old friends from nycflights13 package: `flights` and `planes`.

-   These datasets are easy to get into our learning database because dbplyr comes with a function that copies the tables from nycflights13 to our database:

    ```{r}
    dbplyr::copy_nycflights13(con)
    flights <- tbl(con, "flights")
    planes <-tbl(con, "planes")
    ```

### 21.5.1 SQL basics

-   The top-level components of SQL are called **statements.**

-   Common statements include `CREATE` for defining new tables, `INSERT` for adding data, and `SELECT` for retrieving data.

-   We will focus on `SELECT` statements, also called **queries**, because they're are almost exclusively what you'll use as a data scientist.

-   A query is made up of **clauses.** There are five important clauses: `SELECT`, `FROM`, `WHERE`, `ORDER BY`, and `GROUP BY`.

-   Every quest must have the `SELECT` and `FROM` clauses and the simplest query is `SELECT * FROM table`, which selects all columns from the specified table.

-   This is is what dbplyr generates for an unadulterated table:

    ```{r}
    flights %>% 
      show_query()
    ```

    ```{r}
    planes %>% 
      show_query()
    ```

-   `WHERE` and `ORDER BY` control which rows are included and how they are ordered:

    ```{r}
    flights %>% 
      filter(dest == "IAH") %>% 
      arrange(dep_delay) %>% 
      show_query()
    ```

`GROUP BY` converts the query to a summary, causing aggregation to happen:

```{r}
flights %>% 
  group_by(dest) %>% 
  summarize(dep_delay = mean(dep_delay, na.rm = TRUE)) %>% 
  show_query()
```

-   There are two important differences between dplyr verbs and SELECT clauses:

    -   In SQL, case doesn't matter: you can write `select`, `SELECT`, or even `SeLeCt`.

    -   In SQL, order matters: you must always write the clauses in the order `SELECT`, `FROM`, `WHERE`, `GROUP BY`, `ORDER BY`.

#### 21.5.2 SELECT

-   The `SELECT` clause is the workhorse of queries and performs the same job as `select()`, `mutate()`, `rename()`, `relocate()`, and `summarize()`.

    ```{r}
    planes %>% 
      select(tailnum, type, manufacturer, model, year) %>% 
      show_query()
    ```

```{r}
planes %>% 
  select(tailnum, type, manufacturer, model, year) %>% 
  rename(year_built = year) %>% 
  show_query()
```

```{r}
planes %>% 
  select(tailnum, type, manufacturer, model, year) %>% 
  relocate(manufacturer, model, .before = type) %>% 
  show_query()
```

-   This example also shows you how SQL does renaming. In SQL terminology renaming is called **aliasing** and is done with `AS`.

The translations for `mutate()` are similarly straightforward: each variable becomes a new expression in `SELECT`:

```{r}
flights %>% 
  mutate(
    speed = distance / (air_time / 60)
  ) %>% 
  show_query()
```

### 21.5.3 FROM

The `FROM` clauses defines the data source.

### 21.5.4 GROUP BY

`group_by()` is translated to the `GROUP BY` clause and `summarize()` is translated to the `SELECT` clause:

```{r}
diamonds_db %>% 
  group_by(cut) %>% 
  summarize(
    n = n(),
    avg_price(mean(price, na.rm = TRUE))
  ) %>% 
  show_query()
```

### 21.5.5 WHERE

`filter()` is translated to the `WHERE` clause:

```{r}
flights %>% 
  filter(dest == "IAH" | dest == "HOU") %>% 
    show_query()
```

```{r}
flights %>% 
  filter(arr_delay > 0 & arr_delay < 20) %>% 
  show_query()
```

-   There are a few important details to note here:

    -   `|` becomes `OR` and `&` becomes `AND`.

    -   SQL uses `=` for comparison, not `==`. SQL doesn't have assignment, so there's no potential for confusion there.

    -   `SQL` uses only `''` for strings, not `""`. In SQL, `""` is used to identify variables.

-   
